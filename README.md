# Memory-Leaks-in-JavaScript
## JS的垃圾回收机制与内存泄漏
### 内存溢出：指的是程序向系统申请一定大小内存，而系统不能满足程序的要求就是内存的溢出。
### 内存泄漏：指申请的内存一直得不到释放，GC回收不了。
### JavaScript是所谓的垃圾收集语言之一。垃圾收集语言通过定期检查哪些先前分配的内存仍然可以从应用程序的其他部分“到达”，帮助开发人员管理内存
### JS中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。
```
function test(){
 var a = 10 ;  //被标记 ，进入环境 
 var b = 20 ;  //被标记 ，进入环境
}
test();        //执行完毕之后 a、b又被标离开环境，被回收
```
### 大多数垃圾收集器使用称为标记和扫描的算法。该算法由以下步骤组成：
### 垃圾收集器建立一个“根”列表。根通常是全局变量，引用保存在代码中。在JavaScript中，“窗口”对象是一个可以充当根的全局变量的例子。### 窗口对象总是存在的，所以垃圾收集器可以认为它和它的所有孩子总是存在的（即不是垃圾）。
### 所有的根都被检查并标记为活动的（即不是垃圾）。所有的孩子都会被递归检查。从根到达的所有内容都不被视为垃圾。
### 所有未标记为活动的内存现在可以被视为垃圾。收集器现在可以释放该内存并将其返回到操作系统。
### 现代垃圾收集器以不同的方式改进了这种算法，但其实质是相同的：可达到的内存块被标记为这样，其余的则被认为是垃圾
### 不需要的引用是指开发人员知道他或她不再需要的内存块的引用，但由于某种原因，它们被保存在活动根目录树的内部。在JavaScript的上下文中，不需要的引用是代码中的某些地方不再使用的变量，并指向一块本来可以释放的内存。有人会认为这是开发商的错误
### 因此，为了理解哪些是JavaScript中最常见的泄漏，我们需要知道在哪些方面通常会遗忘引用。

## 那些情况导致JS内存泄漏：
### 1. 全局变量：全局变量会导致内存泄漏
### 全局变量根据定义是不可收回的（除非被忽略或重新分配）。特别是，用于临时存储和处理大量信息的全局变量值得关注。如果您必须使用全局变量来存储大量数据，请务必将其清空或在完成后重新分配它

### 2. 闭包会导致内存泄漏,解决方法是，在退出函数之前，将不使用的局部变量全部删除。
```
// 变量x虽是在函数内的局部变量，但是由于被闭包函数引用，在第一次执行闭包时其实是将x又被闭包函数使用了，导致x无法再A()执行完后被销毁。一直缓存在内存中。
function A() {
    var x = 1;
    return function () {
        console.log(x);
        x++;
        x=null;
    }
    
}
var m1 = A(); //第一次执行A函数
m1(); //1
m1(); //2
m1(); //3
```

```
//变量使用完后进行销毁可避免内存泄漏
 function A() {
    var x = 1;
    return function () {
        console.log(x);
        x = null;
    }
}
var m1 = A(); //第一次执行A函数
m1(); //1
m1(); //null
m1(); //null
```
### 3. js对象与dom对象循环引用导致内存泄漏
```
// DOM监听事件不可能是局部作用域的，是全局作用域的，因此会把局部变量暴露在全局。
function (){
    var obj = document.getElementById("element");
    obj.onclick = function(){
        console.log('js对象与dom对象循环引用导致了内存泄漏');
    };
}
```

```
//解决,给DOM元素解绑
var obj = document.getElementById("element");
obj.onclick = function(){
    obj.onclick=null;
    console.log('js对象与dom对象循环引用导致了内存泄漏');
};

```
### 4. 定时器导致的内存泄漏,因此需要清空定时器
```
var someResource = getData();
var val = setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource));
    }
}, 1000);
//解决方法，先停止定时器
clearTimeout(val);
node=null；
```
